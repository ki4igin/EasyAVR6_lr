#include <avr/io.h>
#include <avr/interrupt.h>

#include "main.h"
#include "sevseg.h"

uint8_t num_byte = {0};
uint8_t cnt_rx_bytes = {0};

/* Прерывание используется для обработки нажатий кнопок */
ISR(TIMER2_OVF_vect)
{
    if ((PINB & (1 << PINB6)) == 0)
    {
        if (flags.is_btn_lock == 0)
        {
            flags.is_btn_lock = 1;

            num_byte++;
            if (num_byte >= NBUF_RX)
            {
                num_byte = 0;
            }
        }
    }
    else if ((PINB & (1 << PINB7)) == 0)
    {
        if (flags.is_btn_lock == 0)
        {
            flags.is_btn_lock = 1;
            flags.tx = 1;
        }
    }
    else
    {
        flags.is_btn_lock = 0;
    }
}

/* Прерывание используется для обработки нажатий кнопок */
ISR(TIMER1_COMPA_vect)
{
    cnt_rx_bytes = 0;
    TCCR1B &= ~((1 << CS12) | (1 << CS11) | (1 << CS10));
}

/*******************************************************************************
Timer0 Overflow Handler
������������ ��� ����������� ����� �������� ������ �� ������������� �����������  
*******************************************************************************/
ISR(TIMER0_OVF_vect)
{
    uint8_t buf[4];       // ����� ��� �������� 4-� ���������� ����� ���
    uint8_t *pbuf = buf;  // ������ �� �������������� ����������

    // ���������� ����� ������ � ������� num_byte �� ��������� ���������� temp �
    // ������������ 4-� ���������� ����� ��� �����������:
    // 1 ������: ������� ����� ����� �������� ������ � ������� num_byte;
    // 2 ������: ������� ����� ����� �������� ������ � ������� num_byte;
    // 3 ������: ������ ������;
    // 4 ������: ����� num_byte
    uint8_t temp = dataRx[num_byte];

    *pbuf++ = temp & 0x0F;
    *pbuf++ = temp >> 4;
    *pbuf++ = 16;  // ������ ������
    *pbuf++ = num_byte;

    // ����������� �� 4-� �������������� ����������� 4-� ���������� �����
    // (����������� ������ ��� ����� ������ ������ ��������� 4)
    SemsegDisp(buf, sizeof(buf));
}

/*******************************************************************************
USART RX Complete Handler
������������ ��� ������ ������ ������
*******************************************************************************/
ISR(USART_RXC_vect)
{
    // ���� ������� ������ ����, �� ���������� ������� ������� �1 � �������� ���
    // (��������� ������� ������ ������)
    if (cnt_rx_bytes == 0)
    {
        TCNT1 = 0;
        TCCR1B |= (1 << CS10);
    }

    // ������ ��������� ����� � ����� bufRx � ���������� �������� �������� ����
    // ���� ������� �������� ���� ����� NBUF_RX,
    // �� ������������� ������ �1, ���������� ������� �������� ���� �
    // ������������� ���� rx
    bufRx[cnt_rx_bytes] = UDR;
    cnt_rx_bytes++;
    if (cnt_rx_bytes == NBUF_RX)
    {
        TCCR1B &= ~((1 << CS12) | (1 << CS11) | (1 << CS10));
        cnt_rx_bytes = 0;
        flags.rx = 1;
    }
}

/*******************************************************************************
UDR Empty Handler
������������ ��� �������� ������ ������
*******************************************************************************/
ISR(USART_UDRE_vect)
{
    static uint8_t cntTx;  // ������� ���������� ����

    // �������� ����� �� ������ bufTx � ���������� �������� ���������� ����
    // ���� ������� ���������� ���� ����� NBUF_TX,
    // �� ��������� �������� (��������� ���������� �� ����������� ��� UDR) �
    // ���������� ������� ���������� ����
    UDR = bufTx[cntTx];
    cntTx++;
    if (cntTx == NBUF_TX)
    {
        UCSRB &= ~(1 << UDRIE);
        cntTx = 0;
    }
}
// End File --------------------------------------------------------------------