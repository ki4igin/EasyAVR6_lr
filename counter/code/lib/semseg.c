// Includes --------------------------------------------------------------------
#include "semseg.h"
#include <avr/pgmspace.h>  // Заголовчный файл для работы с памятью программ МК

// Macros ---------------------------------------------------------------------
#define DATA_PORT PORTC  // Порт данных к которому подключены
#define DATA_DDR  DDRC   // семисегментные индикаторы.

#define CTRL_PORT PORTB  // Управляющий порт к которому подключены общие
#define CTRL_DDR  DDRB   // катоды/аноды семисегментных индикаторов
#define CTRL_PIN3 3      // Номер вывода общего а/к четвертого индикатора
#define CTRL_PIN2 2      // Номер вывода общего а/к третьего индикатора
#define CTRL_PIN1 1      // Номер вывода общего а/к второго индикатора
#define CTRL_PIN0 0      // Номер вывода общего а/к четвертого индикатора

#define CTRL_PIN_MASK ((1 << CTRL_PIN3) | (1 << CTRL_PIN2) | \
                       (1 << CTRL_PIN1) | (1 << CTRL_PIN0))

// Constants -------------------------------------------------------------------
// Таблица перекодировки символов в памяти программ
const uint8_t tableDecoder[10] PROGMEM = {
    0b11111100,  // код "0"
    0b01100000,  // код "1"
    0b11011010,  // код "2"
    0b11110010,  // код "3"
    0b01100110,  // код "4"
    0b10110110,  // код "5"
    0b10111110,  // код "6"
    0b11100000,  // код "7"
    0b11111110,  // код "8"
    0b11110110   // код "9"
};

// Functions prototypes --------------------------------------------------------

// Functions -------------------------------------------------------------------
/*******************************************************************************
Функция инициализации 4-х семисегментных индикаторов
Выводы данных подключены к DATA_PORT
Выводы управления подключены к CTRL_PORT
*******************************************************************************/
void SemsegInit(void)
{
    // Инициализация выводов подключенных к индикаторам и
    // включение первого индикатора
    DATA_DDR = 0xFF;
    DATA_PORT = 0x00;
    CTRL_DDR |= CTRL_PIN_MASK;
    CTRL_PORT &= ~CTRL_PIN_MASK;

    CTRL_PORT |= (1 << CTRL_PIN0);
}

/*******************************************************************************
Функция перевода 2-х байтного числа в 4-х разрядное двоично-десятичное число.

Аргументы:
data:       исходное 2-байтное число
buf:        указатель на 4-х байтный буфер, в который записывается
            преобразованное 4-х разрядное двоично-десятичное число.
bufSize:    размер буфера, должен строго равняться 4
*******************************************************************************/
void SemsegBin2Bcd(uint16_t data, uint8_t *pbuf, uint8_t bufSize)
{
    if (bufSize != 4)
    {
        return;
    }

    pbuf += bufSize - 1;  // Установка указателя буфера на последний (старший)
                          // элемент

    *pbuf-- = data / 1000;  // Вычисление 4 разряда двоично-десятичного числа
    data %= 1000;           //
    *pbuf-- = data / 100;   // Вычисление 3 разряда двоично-десятичного числа
    data %= 100;            //
    *pbuf-- = data / 10;    // Вычисление 2 разряда двоично-десятичного числа
    data %= 10;             //
    *pbuf-- = data / 1;     // Вычисление 1 разряда двоично-десятичного числа
    data %= 1;
}

/*******************************************************************************
Функция отображения 4-х разрядного двоично-десятичного числа на 4-х
семисегментных индикаторах.

Аргументы:
buf:        указатель на 4-х байтный буфер, в котором расположено
            4-х разрядное двоично-десятичное число.
bufSize:    размер буфера, должен строго равняться 4
*******************************************************************************/
void SemsegDisp(uint8_t *buf, uint8_t bufSize)
{
    if (bufSize != 4)
    {
        return;
    }

    uint8_t ind = 0;  // Переменная для хранения разряда числа

    // Выключение отображения на семисегментных индикаторах
    DATA_PORT = 0x00;

    // Если активен 4-й индикатор, то его выключаем, включаем 1-й индикатор,
    // в ind записываем 1-й разряд двоично-десятичного числа.
    // Если активен 1-й индикатор, то его выключаем, включаем 2-й индикатор,
    // в ind записываем 2-й разряд двоично-десятичного числа.
    // Если активен 2-й индикатор, то его выключаем, включаем 3-й индикатор,
    // в ind записываем 3-й разряд двоично-десятичного числа.
    // Если активен 3-й индикатор, то его выключаем, включаем 4-й индикатор,
    // в ind записываем 4-й разряд двоично-десятичного числа.
    // Если ни один из индикаторов, не активен, то выходим из функции
    if (CTRL_PORT & (1 << CTRL_PIN3))
    {
        CTRL_PORT &= ~(1 << CTRL_PIN3);
        CTRL_PORT |= (1 << CTRL_PIN0);
        ind = buf[0];
    }
    else if (CTRL_PORT & (1 << CTRL_PIN0))
    {
        CTRL_PORT &= ~(1 << CTRL_PIN0);
        CTRL_PORT |= (1 << CTRL_PIN1);
        ind = buf[1];
    }
    else if (CTRL_PORT & (1 << CTRL_PIN1))
    {
        CTRL_PORT &= ~(1 << CTRL_PIN1);
        CTRL_PORT |= (1 << CTRL_PIN2);
        ind = buf[2];
    }
    else if (CTRL_PORT & (1 << CTRL_PIN2))
    {
        CTRL_PORT &= ~(1 << CTRL_PIN2);
        CTRL_PORT |= (1 << CTRL_PIN3);
        ind = buf[3];
    }
    else
    {
        return;
    }

    // Вывод в порт данных семисегментного индикатора значение разряда
    // двоично-десятичного числа, который храниться в ind,
    // используя таблицу перекодировки символов tableDecoder
    uint8_t temp = pgm_read_byte(&tableDecoder[ind]);
    DATA_PORT = temp;
}

/*******************************************************************************
Функция выключения семисегментных индикаторов
*******************************************************************************/
void SemsegOff(void)
{
    DATA_PORT = 0x00;
}
// End File --------------------------------------------------------------------